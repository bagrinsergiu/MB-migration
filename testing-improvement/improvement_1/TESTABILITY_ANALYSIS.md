# Анализ тестируемости проекта MB-migration

## Резюме

Проект представляет собой систему миграции проектов из Ministry Brands в Brizy. Анализ кодовой базы выявил **критические проблемы с тестируемостью**, которые препятствуют созданию надежных автоматических тестов и CI/CD пайплайнов.

---

## Критические проблемы

### 1. Глобальное состояние и синглтоны

#### Проблема
Проект активно использует паттерн Singleton и статические свойства, что создает глобальное состояние, которое невозможно изолировать в тестах.

**Примеры:**
- `Logger::instance()` - синглтон для логирования
- `VariableCache::getInstance()` - синглтон для кэширования
- `DBConnector::getInstance()` - синглтон для подключения к БД
- `Config` - класс со статическими свойствами (20+ статических полей)

**Последствия:**
- Невозможно изолировать тесты друг от друга
- Состояние одного теста влияет на другие
- Невозможно запускать тесты параллельно
- Сложно мокировать зависимости

---

### 2. Прямое создание зависимостей

#### Проблема
Зависимости создаются напрямую через `new ClassName()` внутри методов, а не инжектируются через конструктор.

**Примеры:**
```php
// В BrizyAPI.php
$client = new Client(); // Guzzle HTTP клиент создается внутри метода

// В MBProjectDataCollector.php
$this->fontsController = new FontsController($this->container);

// В различных местах
$browser = BrowserPHP::instance($layoutBasePath);
```

**Последствия:**
- Невозможно подменить зависимости моками
- Тесты требуют реальных внешних сервисов
- Невозможно тестировать компоненты изолированно
- Высокая связанность компонентов

---

### 3. Отсутствие интерфейсов для ключевых компонентов

#### Проблема
Многие классы не имеют интерфейсов, что делает невозможным создание моков.

**Примеры отсутствующих интерфейсов:**
- `VariableCache` - нет интерфейса
- `DBConnector` - нет интерфейса
- `QueryBuilder` - нет интерфейса
- `FontsController` - нет интерфейса
- `BrowserPHP` - есть интерфейс `BrowserInterface`, но используется синглтон
- Множество классов в `Builder/Layout` - нет интерфейсов

**Существующие интерфейсы (частично решают проблему):**
- `BrizyAPIInterface` - есть, используется
- `MBProjectDataCollectorInterface` - есть, используется
- `BrowserInterface` - есть, но реализация использует синглтон

**Последствия:**
- Невозможно создать моки для большинства компонентов
- Тесты вынуждены использовать реальные реализации
- Высокая связанность с внешними зависимостями

---

### 4. Зависимость от внешних сервисов

#### Проблема
Код напрямую обращается к внешним API и базам данных без абстракций.

**Примеры:**
- Прямые HTTP запросы к Brizy API через Guzzle (`new Client()`)
- Прямые SQL запросы к PostgreSQL и MySQL
- Прямые обращения к S3 через AWS SDK
- Прямые обращения к Chrome/Headless браузеру

**Последствия:**
- Тесты требуют реальных внешних сервисов
- Невозможно запускать тесты без интернета
- Тесты медленные и нестабильные
- Невозможно тестировать сценарии ошибок API
- Высокая стоимость тестирования (API лимиты, ресурсы)

---

### 5. Статические свойства и методы

#### Проблема
Класс `Config` использует 20+ статических свойств, которые устанавливаются один раз и используются везде.

**Примеры:**
```php
Config::$mainToken
Config::$urlAPI
Config::$devMode
Config::$cachePath
// и еще 17+ статических свойств
```

**Последствия:**
- Невозможно изменить конфигурацию для тестов
- Состояние конфигурации сохраняется между тестами
- Невозможно тестировать с разными конфигурациями
- Глобальное состояние, которое влияет на все тесты

---

### 6. Тесная связанность компонентов

#### Проблема
Компоненты знают о деталях реализации других компонентов, что создает высокую связанность.

**Примеры:**
- `MigrationPlatform` знает о деталях `PageController`
- `PageController` знает о деталях `BrizyAPI`
- Классы в `Builder/Layout` напрямую используют другие классы
- Нет четкого разделения слоев

**Последствия:**
- Изменение одного компонента требует изменений в других
- Невозможно тестировать компоненты изолированно
- Высокая сложность рефакторинга
- Сложно понять границы ответственности

---

### 7. Отсутствие Dependency Injection контейнера

#### Проблема
Нет централизованного механизма управления зависимостями.

**Последствия:**
- Зависимости создаются в разных местах по-разному
- Невозможно централизованно управлять жизненным циклом объектов
- Сложно подменять зависимости для тестов
- Дублирование кода создания зависимостей

---

### 8. Кэширование и состояние

#### Проблема
`VariableCache` используется как глобальное хранилище состояния, которое сохраняется между вызовами.

**Последствия:**
- Состояние кэша влияет на результаты тестов
- Невозможно изолировать тесты
- Сложно тестировать сценарии с разным состоянием кэша
- Невозможно сбросить состояние между тестами

---

### 9. Отсутствие тестовой инфраструктуры

#### Проблема
Нет инфраструктуры для создания тестовых данных и моков.

**Отсутствует:**
- Фабрики для создания тестовых объектов
- Моки для внешних сервисов
- Тестовые данные (fixtures)
- Утилиты для изоляции тестов
- Тестовые конфигурации

**Последствия:**
- Каждый тест должен создавать все зависимости вручную
- Дублирование кода в тестах
- Сложность написания новых тестов
- Высокий порог входа для написания тестов

---

### 10. Прямые обращения к файловой системе

#### Проблема
Код напрямую работает с файловой системой без абстракций.

**Примеры:**
- `file_get_contents()`, `file_put_contents()`
- `mkdir()`, `unlink()`
- Работа с путями через строки

**Последствия:**
- Тесты требуют реальной файловой системы
- Невозможно изолировать тесты
- Проблемы с правами доступа
- Сложно тестировать сценарии ошибок файловой системы

---

## Что нужно сделать для улучшения тестируемости

### Приоритет 1: Критические изменения

1. **Убрать синглтоны**
   - Заменить `Logger::instance()` на инжекцию через конструктор
   - Заменить `VariableCache::getInstance()` на инжекцию
   - Заменить `DBConnector::getInstance()` на инжекцию
   - Создать фабрики для создания объектов

2. **Убрать статические свойства из Config**
   - Преобразовать `Config` в обычный класс с инстансами
   - Инжектировать `Config` через конструктор
   - Создать `ConfigInterface` для возможности мокирования

3. **Создать интерфейсы для всех ключевых компонентов**
   - `CacheInterface` для `VariableCache`
   - `DatabaseInterface` (частично есть, нужно расширить)
   - `HttpClientInterface` для HTTP запросов
   - `FileSystemInterface` для работы с файлами
   - Интерфейсы для всех классов в `Builder/Layout`

4. **Внедрить Dependency Injection**
   - Добавить DI контейнер (например, PHP-DI или Symfony DI)
   - Инжектировать все зависимости через конструктор
   - Создать фабрики для сложных объектов

### Приоритет 2: Важные изменения

5. **Абстрагировать внешние зависимости**
   - Создать `HttpClientInterface` и обернуть Guzzle
   - Создать `DatabaseInterface` и обернуть PDO
   - Создать `S3ClientInterface` и обернуть AWS SDK
   - Создать `BrowserInterface` (частично есть, нужно доработать)

6. **Разделить слои архитектуры**
   - Четко разделить Domain, Application, Infrastructure слои
   - Использовать паттерн Repository для доступа к данным
   - Использовать паттерн Service для бизнес-логики

7. **Создать тестовую инфраструктуру**
   - Фабрики для создания тестовых объектов
   - Моки для всех внешних зависимостей
   - Тестовые данные (fixtures)
   - Утилиты для изоляции тестов

### Приоритет 3: Улучшения

8. **Рефакторинг для снижения связанности**
   - Применить принцип Dependency Inversion
   - Использовать события (Event-driven) для слабой связанности
   - Разбить большие классы на меньшие

9. **Добавить тестовые конфигурации**
   - Отдельные конфигурации для unit, integration, e2e тестов
   - Возможность переключения между реальными и моковыми сервисами

10. **Создать тестовые утилиты**
    - Helpers для создания тестовых данных
    - Assertions для проверки результатов миграции
    - Утилиты для очистки состояния между тестами

---

## Рекомендации по тестированию

### Типы тестов, которые можно создать после рефакторинга

1. **Unit тесты**
   - Тестирование отдельных классов с моками
   - Быстрые тесты (< 1 секунды каждый)
   - Изолированные тесты

2. **Integration тесты**
   - Тестирование взаимодействия компонентов
   - Использование тестовых БД и моков API
   - Средняя скорость (несколько секунд)

3. **E2E тесты**
   - Тестирование полного процесса миграции
   - Использование тестовых проектов
   - Медленные тесты (минуты)

### CI/CD пайплайн

После рефакторинга можно создать пайплайн:
1. **Unit тесты** - запускаются при каждом коммите (< 1 минуты)
2. **Integration тесты** - запускаются при PR (несколько минут)
3. **E2E тесты** - запускаются перед релизом (десятки минут)

---

## Оценка сложности рефакторинга

### Высокая сложность
- Убрать синглтоны (затрагивает весь код)
- Убрать статические свойства из Config (затрагивает весь код)
- Создать интерфейсы для всех компонентов (много работы)

### Средняя сложность
- Внедрить DI контейнер
- Абстрагировать внешние зависимости
- Создать тестовую инфраструктуру

### Низкая сложность
- Создать тестовые утилиты
- Добавить тестовые конфигурации
- Написать документацию по тестированию

---

## Заключение

Проект имеет **критические проблемы с тестируемостью**, которые делают невозможным создание надежных автоматических тестов в текущем состоянии. 

**Основные препятствия:**
1. Глобальное состояние (синглтоны, статические свойства)
2. Прямое создание зависимостей
3. Отсутствие интерфейсов
4. Зависимость от внешних сервисов

**Для достижения тестируемости необходимо:**
1. Провести масштабный рефакторинг (оценка: 2-3 месяца работы)
2. Внедрить Dependency Injection
3. Создать интерфейсы для всех компонентов
4. Абстрагировать внешние зависимости
5. Создать тестовую инфраструктуру

**После рефакторинга можно будет:**
- Создавать unit тесты для всех компонентов
- Запускать тесты в CI/CD при каждом билде
- Быстро находить регрессии
- Уверенно добавлять новые фичи

---

*Анализ выполнен без учета документации, на основе анализа кодовой базы*
