---
name: dwr-next
description: Continues an existing DWR cycle with new context (logs, errors, additional fixes). Use when the user wants to continue working on a previously started task, provides error output or logs from running the code, or wants to apply additional fixes after a completed DWR cycle. Triggered by "/dwr-next" or phrases like "продолжи задачу", "вот ошибки", "дополнительные правки".
---

# DWR-NEXT: Продолжение цикла разработки

Запускает **продолжение** ранее выполненного DWR-цикла. Читает контекст предыдущей сессии из `task/`, принимает новый контекст (логи, ошибки, дополнительные требования) и прогоняет их через **task-decomposer → task-worker → work-reviewer**.

Каждый шаг выполняется **в отдельном агенте** (отдельном контексте) — так же, как в основном DWR.

## Роль оркестратора: только управление (строго)

Оркестратор выполняет **только следующие действия**:
1. Читает `session.md` и артефакты (`impl_*.md`, `review_r*.md`) для загрузки контекста предыдущего цикла.
2. Запускает суб-агентов (Task).
3. Читает артефакты суб-агентов и обновляет `session.md` (только `Status`, `Round`, краткие секции).

### ЗАПРЕЩЕНО оркестратору

- Читать файлы кодовой базы (`.php`, `.js`, `.json`, `.css` и т.д.)
- Искать код или символы (grep, find, get_symbols и любые поисковые инструменты)
- Анализировать код, архитектуру или зависимости
- Формулировать технические выводы по коду
- Писать или предлагать реализацию
- Проводить ревью кода
- Самостоятельно «уточнять» или «дополнять» задачу

### Правило при нехватке информации

Если новый контекст (логи, ошибки) неполный или что-то неясно —
**передать декомпозеру как есть, без предварительного сбора контекста**.
Декомпозер сам анализирует кодовую базу и при необходимости задаёт уточняющий вопрос.

## Когда применять

- Пользователь завершил `/dwr` и хочет продолжить с новыми данными
- Есть логи или ошибки из запуска/тестирования, которые нужно исправить
- Появились дополнительные требования к той же задаче
- Предыдущий цикл завершился, но результат нужно доработать

## Входные данные от пользователя

Пользователь передаёт только новый контекст:

| Поле | Описание | Обязательно |
|---|---|---|
| `new_context` | Логи, ошибки, трассировки, новые требования | Да (хотя бы одно) |
| `session_id` | Номер сессии вида `NNN` или `NNN_datetime` (если нужна не последняя) | Нет (по умолчанию — последняя) |

`previous_task` и `affected_files` **не нужно вводить вручную** — они читаются автоматически из `session.md`.

---

## Порядок выполнения

Выполнять **строго по шагам**.

---

### Шаг 0: Загрузка контекста предыдущей сессии

1. Найти директорию сессии:
   - Если пользователь указал `session_id` → использовать `task/{session_id}/`
   - Иначе → найти последнюю: просмотреть `task/`, найти директории вида `NNN_*`, взять с наибольшим номером
2. Прочитать `task/{session_id}/session.md` и извлечь:
   - `Task` → это `previous_task`
   - `Affected Files` → список файлов из предыдущего цикла
   - `Status` → определить режим загрузки (см. ниже)
   - `Round` → последний раунд предыдущего цикла
3. Определить номер текущего запуска dwr-next (M):
   - Посмотреть количество файлов вида `*_next*` в директории сессии → M = количество + 1
4. Все новые артефакты этого запуска записываются в ту же директорию: `task/{session_id}/` с суффиксом `_next{M}`.

**Если `Status = escalated`:**
- Найти последний файл `review_r{N}.md` в директории сессии.
- Извлечь секцию `### Blocker Report` — это будет обязательным контекстом для декомпозера.
- Сообщить пользователю: «Предыдущий цикл завершился с нерешёнными блокерами. Blocker Report передаётся декомпозеру как приоритетный контекст.»

**Сбор Discoveries из предыдущего цикла:**
- Найти все файлы `impl_r*.md` в директории сессии.
- Из каждого извлечь секцию `## Discoveries` (если есть).
- Объединить в список `previous_discoveries` для передачи декомпозеру.

5. Если `session.md` не найден или `task/` пуста — попросить пользователя описать предыдущую задачу вручную.

---

### Шаг 1: Запуск «task-decomposer» — декомпозиция с новым контекстом

- **Вызвать суб-агента task-decomposer в его собственном контексте.** Суб-агент: `.cursor/agents/task-decomposer.md`.
- **Передать:**
  ```
  Задача: Декомпозируй новый контекст в список задач на исправление.

  Исходная задача (из предыдущего DWR):
  [previous_task из session.md]

  Новый контекст (логи / ошибки / дополнительные требования):
  [new_context от пользователя]

  Затронутые файлы (из предыдущего цикла): [Affected Files из session.md]
  Директория сессии: task/{session_id}/
  Раунд: 0 (next{M})
  Запиши результат в: task/{session_id}/decomp_next{M}_r0.md
  (не пиши в session.md — оркестратор перенесёт данные сам)

  [Если escalated:]
  BLOCKER REPORT из предыдущего цикла (обязательно учесть при декомпозиции):
  [содержимое Blocker Report из review_r{N}.md]

  [Если есть previous_discoveries:]
  Discoveries из предыдущего цикла:
  [список previous_discoveries]
  ```
- **Результат:** файл `decomp_next{M}_r0.md` со списком задач на исправление.

После получения результата оркестратор:
- Читает `decomp_next{M}_r0.md`
- Добавляет в `session.md` секцию `## Next {M}: Decomposition` (3-5 строк: кол-во задач, порядок, ключевые файлы)
- `Status` → `in_progress`

> Если новый контекст содержит и ошибки, и новые требования — декомпозитор разделяет их на отдельные задачи.

---

### Шаг 2: Параллельный запуск «task-worker» — реализация по волнам

Оркестратор выполняет волны **последовательно**, внутри каждой волны — воркеры **параллельно**.

#### Для каждой волны:

**2а. Параллельный запуск воркеров**

- Для каждой подзадачи волны — отдельный вызов task-worker.
- **Передать:**
  ```
  Подзадача: [название и описание из decomposer]
  Критерий готовности: [скопировать из вывода decomposer]
  Релевантные файлы/модули: [список из decomposer или Affected Files]
  Контекст: это исправление по логам/ошибкам задачи «[previous_task]»
  Директория сессии: task/{session_id}/
  Раунд: 0, Волна: {W}, Подзадача: {K}  (next{M})
  Записывай результат в: task/{session_id}/impl_next{M}_w{W}_t{K}.md
  (не пиши напрямую в session.md)
  Discoveries из предыдущих волн (если есть): [список]
  ```
- **Ждать завершения всех воркеров волны.**

**2б. Wave Gate (обработка результатов волны)**

После завершения всех воркеров волны оркестратор читает `impl_next{M}_w{W}_*.md`:

- **BLOCKED**: если есть — запустить mid-cycle re-decomposition (max 1):
  ```
  Задача: Уточни декомпозицию заблокированных подзадач.
  Заблокированные подзадачи: [список с причинами]
  Директория сессии: task/{session_id}/
  Запиши в: task/{session_id}/decomp_next{M}_reblock.md
  ```
- **NOT MET**: если есть — немедленный fix loop.
- **Discoveries**: собрать из всех артефактов волны для передачи следующей волне.
- **Merge**: для успешных артефактов — добавить в `session.md` секцию `## Next {M}: Implementation Wave {W}` + обновить `## Affected Files`.

**2в. Следующая волна**

Запустить только после Wave Gate предыдущей. Передавать собранные Discoveries.

---

### Шаг 3: Запуск «work-reviewer» — проверка результата

- **Вызвать суб-агента work-reviewer в его собственном контексте.** Суб-агент: `.cursor/agents/work-reviewer.md`.
- **Передать:**
  ```
  Проверь результат выполнения задачи: [название задачи / краткое описание]
  Исходная задача: [previous_task из session.md]
  Изменения: [@файлы или дифф / описание]
  Контекст исправления: [new_context — логи/ошибки, которые были переданы]
  Директория сессии: task/{session_id}/
  Раунд: 0 (next{M})
  Последний раунд: да/нет  ← «да» если это раунд 3 fix loop
  Записывай результат в: task/{session_id}/review_next{M}_r0.md
  (не пиши напрямую в session.md)
  ```
- **Результат:** файл `review_next{M}_r0.md`. Код в этом шаге не править.

После получения результата оркестратор:
- Читает `review_next{M}_r0.md`
- Добавляет в `session.md` секцию `## Next {M}: Review` (вердикт + одна строка итога)
- `Round` → инкрементировать
- Если ревьюер вернул Blocker Report → `Status` → `escalated`

---

### Fix loop (при критичных/важных замечаниях)

Если ревьюер указал **критичные или важные** замечания и раунд **< 3**:

**Шаг 3а: Запуск «task-decomposer» — декомпозиция замечаний ревью**

- **Передать:**
  ```
  Задача: Декомпозируй замечания ревью в список задач на исправление.

  Отчёт ревью:
  [полный вывод work-reviewer — критичные и важные замечания]

  Контекст: задача «[previous_task]», исправлялось по: [new_context краткое]
  Затронутые файлы: [Affected Files из session.md]
  Директория сессии: task/{session_id}/
  Раунд: {N+1} (next{M})
  Discoveries из предыдущих волн (если есть): [список]
  Запиши результат в: task/{session_id}/decomp_next{M}_r{N+1}.md
  ```

Оркестратор:
- `Round` → инкрементировать
- `Status` → `fix_loop`
- Добавить секцию `## Next {M}: Decomposition Round {N+1}` в `session.md`

**Шаг 3б: Запуск «task-worker» — исправление по волнам**

Аналогично шагу 2 (включая Wave Gate). Файлы: `impl_next{M}_r{N+1}_w{W}_t{K}.md`.

После шага 3б — снова **шаг 3**. Максимум **3 раунда**.

---

### Завершение цикла

- Если замечаний нет / только рекомендации / достигнут лимит раундов:
  - Читает последний `review_next{M}_r{N}.md`
  - Если Blocker Report → `Status` → `escalated`
  - Иначе если рекомендации → `Status` → `awaiting_next`
  - Иначе → `Status` → `completed`
  - Добавить финальное резюме в `session.md`
- Написать итог: что исправлено, какой контекст был передан, сколько раундов fix loop, статус ревью, путь `task/{session_id}/`.

---

## Краткая схема

```
[/dwr-next: new_context]
        ↓
   [0. Найти task/{NNN}_{datetime}/, читать session.md]
      → если escalated: извлечь Blocker Report из review_r{N}.md
      → собрать Discoveries из impl_r*.md
        ↓
   [1. task-decomposer + Blocker Report (если есть) + Discoveries] → decomp_next{M}_r0.md
        ↓
   [2. task-worker × N (параллельно)] → impl_next{M}_w{W}_t{K}.md
        ↓ Wave Gate (BLOCKED / NOT MET / Discoveries / merge→session.md)
   [2. следующие волны...]
        ↓
   [3. work-reviewer + Исходная задача + Последний раунд] → review_next{M}_r0.md
        ↓
   Критичные/важные? → нет: Status=completed/awaiting_next → ЗАВЕРШЕНО
                     ↓ да (раунд < 3)
   [3а. task-decomposer + Discoveries] → decomp_next{M}_r{N+1}.md
        ↓
   [3б. task-worker × N (параллельно)] + Wave Gate
        ↓
   [3. work-reviewer, Последний раунд=да если N==3] → review_next{M}_r{N+1}.md
        ↓ (повторять 3а → 3б → 3, макс. 3 раунда)
        ↓ раунд==3 с критичными → Status=escalated
```

## Важно

- **Это продолжение предыдущей задачи**, а не новый независимый DWR. `previous_task` берётся из `session.md` автоматически.
- **Если `Status = escalated`** — Blocker Report обязательно передаётся декомпозеру.
- **Discoveries** из всех `impl_r*.md` предыдущего цикла передаются декомпозеру шага 1.
- **Артефакты**: все агенты пишут в свои файлы с суффиксом `_next{M}`. **Не пишут в `session.md` напрямую.**
- **`session.md` обновляет только оркестратор** — читает артефакты и переносит краткие секции.
- **Wave Gate** применяется после каждой волны (BLOCKED, NOT MET, Discoveries, merge).
- **Если только логи/ошибки** — декомпозитор разбирает их и формирует задачи на исправление.
- **Если только новые требования** — декомпозитор формирует задачи на доработку.
- **Если и ошибки, и требования** — декомпозитор разделяет на задачи с приоритетами.
- Максимум **3 раунда fix loop**.
- Суб-агенты: `.cursor/agents/task-decomposer.md`, `task-worker.md`, `work-reviewer.md`.
- Язык: ответы оркестратора на русском; тексты для суб-агентов по конвенциям проекта.
